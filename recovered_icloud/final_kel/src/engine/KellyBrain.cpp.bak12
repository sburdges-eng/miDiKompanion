#include "engine/MidiKompanionBrain.h"
// MidiKompanionBrain.h includes MidiKompanionTypes.h, so Wound, EmotionNode, etc. are MidiKompanionTypes versions
// Now we create aliases for the MidiKompanionTypes versions before Types.h redefines them
namespace midikompanion {
    // Alias MidiKompanionTypes versions before Types.h redefines them
    using MidiKompanionTypesWound = Wound;
    using MidiKompanionTypesEmotionNode = EmotionNode;
    using MidiKompanionTypesIntentResult = IntentResult;
    // RuleBreak and RuleBreakType are from kelly:: namespace in Types.h, not from MidiKompanionTypes
    // So we don't create aliases for them here
}

// Now include IntentPipeline.h - this brings in Types.h which redefines the types
#include "engine/IntentPipeline.h"
#include "common/Types.h"  // Explicit include - this redefines Wound, EmotionNode, etc.
#include "midi/MidiGenerator.h"  // For MIDI generation
#include <algorithm>
#include <cctype>

namespace midikompanion {

// Destructor defined here to handle incomplete IntentPipeline type
MidiKompanionBrain::~MidiKompanionBrain() = default;

// Conversion helpers between MidiKompanionTypes.h and Types.h structures
// These work by manually copying fields between compatible structures
namespace {
    // Convert string category to kelly::EmotionCategory enum
    kelly::EmotionCategory categoryFromString(const std::string& categoryStr) {
        std::string lower = categoryStr;
        std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);

        if (lower == "joy" || lower == "happiness" || lower == "happy") return kelly::EmotionCategory::Joy;
        if (lower == "sad" || lower == "sadness") return kelly::EmotionCategory::Sadness;
        if (lower == "anger" || lower == "angry") return kelly::EmotionCategory::Anger;
        if (lower == "fear") return kelly::EmotionCategory::Fear;
        if (lower == "surprise") return kelly::EmotionCategory::Surprise;
        if (lower == "disgust") return kelly::EmotionCategory::Disgust;
        if (lower == "trust" || lower == "love") return kelly::EmotionCategory::Trust;
        if (lower == "anticipation") return kelly::EmotionCategory::Anticipation;
        return kelly::EmotionCategory::Sadness;  // Default
    }
    // Convert MidiKompanionTypes::Wound to Types::Wound
    Wound convertToLegacyWound(const MidiKompanionTypesWound& unified) {
        Wound legacy;  // This is Types::Wound now
        legacy.description = unified.description;
        legacy.intensity = unified.intensity;  // Use compatibility field
        legacy.source = unified.source;        // Use compatibility field
        return legacy;
    }

    // Convert Types::IntentResult to MidiKompanionTypes::IntentResult
    MidiKompanionTypesIntentResult convertFromLegacyIntentResult(const IntentResult& legacy) {
        MidiKompanionTypesIntentResult unified;  // This is MidiKompanionTypes::IntentResult

        // Map wound to sourceWound
        unified.sourceWound.description = legacy.sourceWound.description;
        unified.sourceWound.intensity = legacy.sourceWound.intensity;
        unified.sourceWound.urgency = legacy.sourceWound.intensity;  // urgency = intensity
        unified.sourceWound.source = legacy.sourceWound.source;
        unified.sourceWound.desire = legacy.sourceWound.source;

        // Map emotion to sourceWound.primaryEmotion and also set emotion compatibility field
        unified.sourceWound.primaryEmotion.id = legacy.emotion.id;
        unified.sourceWound.primaryEmotion.name = legacy.emotion.name;
        unified.sourceWound.primaryEmotion.categoryEnum = legacy.emotion.categoryEnum;
        unified.sourceWound.primaryEmotion.category = categoryToString(legacy.emotion.categoryEnum);
        unified.sourceWound.primaryEmotion.valence = legacy.emotion.valence;
        unified.sourceWound.primaryEmotion.arousal = legacy.emotion.arousal;
        unified.sourceWound.primaryEmotion.dominance = legacy.emotion.dominance;
        unified.sourceWound.primaryEmotion.intensity = legacy.emotion.intensity;

        // Also set emotion compatibility field (should match primaryEmotion)
        unified.emotion.id = legacy.emotion.id;
        unified.emotion.name = legacy.emotion.name;
        unified.emotion.categoryEnum = legacy.emotion.categoryEnum;
        unified.emotion.category = categoryToString(legacy.emotion.categoryEnum);
        unified.emotion.valence = legacy.emotion.valence;
        unified.emotion.arousal = legacy.emotion.arousal;
        unified.emotion.dominance = legacy.emotion.dominance;
        unified.emotion.intensity = legacy.emotion.intensity;

        // Set tempo from tempoBpm (convert BPM to modifier)
        unified.tempo = static_cast<float>(unified.tempoBpm) / 120.0f;

        // Map musical parameters
        unified.mode = legacy.mode;
        unified.tempoBpm = static_cast<int>(120 * legacy.tempo);  // tempo is a multiplier
        unified.syncopationLevel = legacy.syncopationLevel;
        unified.humanization = legacy.humanization;
        unified.dynamicRange = legacy.dynamicRange;
        unified.allowChromaticism = legacy.allowDissonance;

        // Convert rule breaks
        unified.ruleBreaks.clear();
        for (const auto& rb : legacy.ruleBreaks) {
            MidiKompanionTypesRuleBreak unifiedRb;  // MidiKompanionTypes::RuleBreak
            // Map RuleBreakType enum values
            // legacy.ruleBreaks uses Types.h RuleBreakType (Harmony, Rhythm, etc.)
            // unified uses MidiKompanionTypes.h RuleBreakType (ModalMixture, CrossRhythm, etc.)
            // At this point, RuleBreakType refers to Types.h version (included last)
            // So we use integer values to map to MidiKompanionTypes version
            switch (rb.type) {
                case RuleBreakType::ModalMixture:  // Types.h version
                    unifiedRb.type = static_cast<MidiKompanionTypesRuleBreakType>(1);  // ModalMixture
                    break;
                case RuleBreakType::CrossRhythm:
                    unifiedRb.type = static_cast<MidiKompanionTypesRuleBreakType>(4);  // CrossRhythm
                    break;
                case RuleBreakType::DynamicContrast:
                    unifiedRb.type = static_cast<MidiKompanionTypesRuleBreakType>(6);  // DynamicContrast
                    break;
                case RuleBreakType::RegisterShift:
                    unifiedRb.type = static_cast<MidiKompanionTypesRuleBreakType>(5);  // RegisterShift
                    break;
                case RuleBreakType::HarmonicAmbiguity:
                    unifiedRb.type = static_cast<MidiKompanionTypesRuleBreakType>(7);  // HarmonicAmbiguity
                    break;
                default:
                    unifiedRb.type = static_cast<MidiKompanionTypesRuleBreakType>(0);  // None
            }
            unifiedRb.description = rb.description;
            unifiedRb.justification = rb.justification;
            unifiedRb.intensity = rb.intensity;
            unified.ruleBreaks.push_back(unifiedRb);
        }

        // Set defaults for unified-only fields
        unified.key = "C";
        unified.timeSignature = {4, 4};
        unified.chordProgression.clear();
        unified.melodicRange = 0.6f;
        unified.leapProbability = 0.3f;
        unified.baseVelocity = 0.6f;
        unified.productionNotes.clear();
        unified.confidence = 0.8f;

        return unified;
    }

    // Convert MidiKompanionTypes::IntentResult to Types::IntentResult (reverse conversion)
    IntentResult convertToLegacyIntentResult(const MidiKompanionTypesIntentResult& unified) {
        IntentResult legacy;  // This is Types::IntentResult

        // Map sourceWound
        legacy.sourceWound.description = unified.sourceWound.description;
        legacy.sourceWound.intensity = unified.sourceWound.intensity;
        legacy.sourceWound.source = unified.sourceWound.source;

        // Map emotion (use primaryEmotion from sourceWound)
        legacy.emotion.id = unified.sourceWound.primaryEmotion.id;
        legacy.emotion.name = unified.sourceWound.primaryEmotion.name;
        legacy.emotion.categoryEnum = unified.sourceWound.primaryEmotion.categoryEnum;
        legacy.emotion.valence = unified.sourceWound.primaryEmotion.valence;
        legacy.emotion.arousal = unified.sourceWound.primaryEmotion.arousal;
        legacy.emotion.dominance = unified.sourceWound.primaryEmotion.dominance;
        legacy.emotion.intensity = unified.sourceWound.primaryEmotion.intensity;

        // Map musical parameters
        legacy.mode = unified.mode;
        legacy.tempo = unified.tempo;  // tempo is a multiplier (0.5 to 2.0)
        legacy.syncopationLevel = unified.syncopationLevel;
        legacy.humanization = unified.humanization;
        legacy.dynamicRange = unified.dynamicRange;
        legacy.allowDissonance = unified.allowChromaticism;

        // Convert rule breaks
        legacy.ruleBreaks.clear();
        for (const auto& rb : unified.ruleBreaks) {
            RuleBreak legacyRb;  // Types::RuleBreak
            // Map MidiKompanionTypes::RuleBreakType to Types::RuleBreakType
            // Use integer values to map
            switch (static_cast<int>(rb.type)) {
                case 1:  // ModalMixture
                    legacyRb.type = RuleBreakType::ModalMixture;
                    break;
                case 4:  // CrossRhythm
                    legacyRb.type = RuleBreakType::CrossRhythm;
                    break;
                case 6:  // DynamicContrast
                    legacyRb.type = RuleBreakType::DynamicContrast;
                    break;
                case 5:  // RegisterShift
                    legacyRb.type = RuleBreakType::RegisterShift;
                    break;
                case 7:  // HarmonicAmbiguity
                    legacyRb.type = RuleBreakType::HarmonicAmbiguity;
                    break;
                default:
                    legacyRb.type = RuleBreakType::None;
            }
            legacyRb.description = rb.description;
            legacyRb.justification = rb.justification;
            legacyRb.intensity = rb.intensity;
            legacy.ruleBreaks.push_back(legacyRb);
        }

        return legacy;
    }
}

MidiKompanionBrain::MidiKompanionBrain() : pipeline_(std::make_unique<IntentPipeline>()) {
    // IntentPipeline is initialized
}

bool MidiKompanionBrain::initialize(const std::string& dataPath) {
    // The existing IntentPipeline already initializes EmotionThesaurus
    // This could load additional data if needed
    initialized_ = true;
    return true;
}

MidiKompanionTypesIntentResult MidiKompanionBrain::fromWound(const MidiKompanionTypesWound& wound) {
    // Wound parameter is MidiKompanionTypes::Wound (from header via alias)
    // Convert to Types::Wound for IntentPipeline
    Wound legacyWound = convertToLegacyWound(wound);  // Wound here is Types::Wound

    // Call IntentPipeline with legacy types
    IntentResult legacyResult = pipeline_->process(legacyWound);  // IntentResult is Types::IntentResult

    // Convert result back to unified types (MidiKompanionTypes::IntentResult)
    return convertFromLegacyIntentResult(legacyResult);
}

MidiKompanionTypesIntentResult MidiKompanionBrain::fromJourney(const SideA& current, const SideB& desired) {
    // SideA/SideB parameters are MidiKompanionTypes versions (from header)
    // Types.h has SideA and SideB with same structure, so we can use them directly
    // Both have: description, intensity, emotionId
    SideA legacyCurrent;  // Types::SideA
    legacyCurrent.description = current.description;
    legacyCurrent.intensity = current.intensity;
    legacyCurrent.emotionId = current.emotionId;

    SideB legacyDesired;  // Types::SideB
    legacyDesired.description = desired.description;
    legacyDesired.intensity = desired.intensity;
    legacyDesired.emotionId = desired.emotionId;

    // Call IntentPipeline
    IntentResult legacyResult = pipeline_->processJourney(legacyCurrent, legacyDesired);  // Types::IntentResult

    // Convert result back to unified types
    return convertFromLegacyIntentResult(legacyResult);
}

MidiKompanionTypesIntentResult MidiKompanionBrain::fromText(const std::string& description) {
    // Create a wound from text description
    Wound wound = descriptionToWound(description);
    return fromWound(wound);
}

MidiKompanionTypesIntentResult MidiKompanionBrain::fromEmotion(const std::string& emotionName, float intensity) {
    // Look up emotion in thesaurus (returns Types.h EmotionNode)
    auto emotionOpt = pipeline_->thesaurus().findByName(emotionName);
    if (emotionOpt) {
        // Create wound from emotion
        MidiKompanionTypesWound wound;
        wound.description = "Feeling " + emotionName;
        wound.urgency = intensity;
        wound.intensity = intensity;
        wound.source = "emotion_selection";
        wound.expression = "Emotion: " + emotionName;

        // Set primary emotion from thesaurus result
        wound.primaryEmotion.id = emotionOpt->id;
        wound.primaryEmotion.name = emotionOpt->name;
        wound.primaryEmotion.categoryEnum = categoryFromString(emotionOpt->category);
        wound.primaryEmotion.category = emotionOpt->category;
        wound.primaryEmotion.valence = emotionOpt->valence;
        wound.primaryEmotion.arousal = emotionOpt->arousal;
        wound.primaryEmotion.dominance = emotionOpt->dominance;
        wound.primaryEmotion.intensity = emotionOpt->intensity;

        return fromWound(wound);
    }

    // Fallback: create basic wound
    return fromText("Feeling " + emotionName);
}

GeneratedMidi MidiKompanionBrain::generateMidi(const MidiKompanionTypesIntentResult& intent, int bars) {
    // Convert unified IntentResult to legacy format for MidiGenerator
    IntentResult legacyIntent = convertToLegacyIntentResult(intent);

    // Use MidiGenerator to generate actual MIDI notes
    static kelly::MidiGenerator midiGenerator;  // Static to reuse instance
    GeneratedMidi result = midiGenerator.generate(legacyIntent, bars);

    // Ensure metadata fields are set for compatibility
    result.tempoBpm = intent.tempoBpm;
    result.bars = bars;
    result.key = intent.key;
    result.mode = intent.mode;
    result.metadata["lengthInBeats"] = std::to_string(bars * 4.0);
    result.metadata["bpm"] = std::to_string(intent.tempoBpm);

    return result;
}

GeneratedMidi MidiKompanionBrain::generateMidiFromWound(const MidiKompanionTypesWound& wound, int bars) {
    MidiKompanionTypesIntentResult result = fromWound(wound);
    return generateMidi(result, bars);
}

MidiKompanionTypesEmotionNode MidiKompanionBrain::resolveEmotionByName(const std::string& emotionName) {
    // Try to find emotion in thesaurus (returns Types.h EmotionNode)
    auto emotionOpt = pipeline_->thesaurus().findByName(emotionName);
    if (emotionOpt) {
        // Convert Types.h EmotionNode to MidiKompanionTypes.h EmotionNode
        MidiKompanionTypesEmotionNode unified;  // MidiKompanionTypes::EmotionNode
        unified.id = emotionOpt->id;
        unified.name = emotionOpt->name;
        unified.categoryEnum = categoryFromString(emotionOpt->category);
        unified.category = emotionOpt->category;
        unified.valence = emotionOpt->valence;
        unified.arousal = emotionOpt->arousal;
        unified.dominance = emotionOpt->dominance;
        unified.intensity = emotionOpt->intensity;
        unified.relatedEmotions = emotionOpt->relatedEmotions;
        // Set defaults for unified-only fields
        unified.synonyms.clear();
        unified.layerIndex = 0;
        unified.subIndex = 0;
        unified.subSubIndex = 0;
        return unified;
    }

    // Fallback: create a basic emotion node (MidiKompanionTypes::EmotionNode)
    MidiKompanionTypesEmotionNode fallback;
    fallback.name = emotionName;
    fallback.intensity = 0.5f;
    fallback.valence = 0.0f;
    fallback.arousal = 0.5f;
    fallback.dominance = 0.5f;
    fallback.categoryEnum = static_cast<EmotionCategory>(0);  // Joy = 0
    fallback.category = "Joy";

    return fallback;
}

std::string MidiKompanionBrain::woundToDescription(const MidiKompanionTypesWound& wound) {
    if (!wound.expression.empty()) {
        return wound.description + " - " + wound.expression;
    }
    return wound.description;
}

MidiKompanionTypesWound MidiKompanionBrain::descriptionToWound(const std::string& description, float intensity) {
    MidiKompanionTypesWound wound;
    wound.description = description;
    wound.urgency = intensity;
    wound.intensity = intensity;
    wound.source = "text_input";
    wound.expression = description;
    return wound;
}

// Implement accessor methods that require IntentPipeline definition
IntentPipeline& MidiKompanionBrain::pipeline() {
    return *pipeline_;
}

const IntentPipeline& MidiKompanionBrain::pipeline() const {
    return *pipeline_;
}

IntentPipeline& MidiKompanionBrain::getIntentPipeline() {
    return *pipeline_;
}

const IntentPipeline& MidiKompanionBrain::getIntentPipeline() const {
    return *pipeline_;
}

EmotionThesaurus& MidiKompanionBrain::thesaurus() {
    return pipeline_->thesaurus();
}

const EmotionThesaurus& MidiKompanionBrain::thesaurus() const {
    return pipeline_->thesaurus();
}

} // namespace kelly
