"""
PWA Configuration - Progressive Web App setup for iDAW.

Generates:
- Web app manifest (manifest.json)
- Service worker for offline support
- Icon assets configuration
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any
from pathlib import Path
import json


@dataclass
class PWAIcon:
    """PWA icon configuration."""
    src: str
    sizes: str
    type: str = "image/png"
    purpose: str = "any maskable"


@dataclass
class PWAManifest:
    """Web App Manifest configuration."""
    name: str = "iDAW"
    short_name: str = "iDAW"
    description: str = "Intelligent Digital Audio Workstation"
    start_url: str = "/"
    display: str = "standalone"
    orientation: str = "any"
    theme_color: str = "#1a1a2e"
    background_color: str = "#16213e"

    # Icons
    icons: List[PWAIcon] = field(default_factory=list)

    # Categories
    categories: List[str] = field(default_factory=lambda: ["music", "productivity"])

    # Shortcuts
    shortcuts: List[Dict[str, str]] = field(default_factory=list)

    # Screenshots
    screenshots: List[Dict[str, str]] = field(default_factory=list)

    # Additional properties
    prefer_related_applications: bool = False
    related_applications: List[Dict[str, str]] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to manifest dictionary."""
        manifest = {
            "name": self.name,
            "short_name": self.short_name,
            "description": self.description,
            "start_url": self.start_url,
            "display": self.display,
            "orientation": self.orientation,
            "theme_color": self.theme_color,
            "background_color": self.background_color,
            "categories": self.categories,
            "prefer_related_applications": self.prefer_related_applications,
        }

        if self.icons:
            manifest["icons"] = [
                {
                    "src": icon.src,
                    "sizes": icon.sizes,
                    "type": icon.type,
                    "purpose": icon.purpose,
                }
                for icon in self.icons
            ]

        if self.shortcuts:
            manifest["shortcuts"] = self.shortcuts

        if self.screenshots:
            manifest["screenshots"] = self.screenshots

        if self.related_applications:
            manifest["related_applications"] = self.related_applications

        return manifest

    def to_json(self, indent: int = 2) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=indent)


@dataclass
class PWAConfig:
    """Full PWA configuration including caching strategies."""
    manifest: PWAManifest

    # Caching
    cache_name: str = "idaw-v1"
    static_cache: List[str] = field(default_factory=list)
    dynamic_cache: bool = True
    max_cache_age_days: int = 30

    # Offline behavior
    offline_page: str = "/offline.html"
    offline_fallback: bool = True

    # Push notifications
    push_enabled: bool = False
    push_public_key: Optional[str] = None

    # Background sync
    background_sync: bool = True


def generate_manifest(config: PWAConfig) -> str:
    """
    Generate web app manifest JSON.

    Args:
        config: PWA configuration

    Returns:
        Manifest JSON string
    """
    return config.manifest.to_json()


def generate_service_worker(config: PWAConfig) -> str:
    """
    Generate service worker JavaScript.

    Args:
        config: PWA configuration

    Returns:
        Service worker JavaScript code
    """
    static_cache = json.dumps(config.static_cache)

    sw_code = f'''// Service Worker for iDAW PWA
// Generated by iDAW Mobile Module

const CACHE_NAME = '{config.cache_name}';
const STATIC_CACHE = {static_cache};
const OFFLINE_PAGE = '{config.offline_page}';

// Install event - cache static assets
self.addEventListener('install', (event) => {{
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then((cache) => {{
                console.log('[SW] Caching static assets');
                return cache.addAll(STATIC_CACHE);
            }})
            .then(() => self.skipWaiting())
    );
}});

// Activate event - cleanup old caches
self.addEventListener('activate', (event) => {{
    event.waitUntil(
        caches.keys()
            .then((cacheNames) => {{
                return Promise.all(
                    cacheNames
                        .filter((name) => name !== CACHE_NAME)
                        .map((name) => caches.delete(name))
                );
            }})
            .then(() => self.clients.claim())
    );
}});

// Fetch event - serve from cache or network
self.addEventListener('fetch', (event) => {{
    // Skip non-GET requests
    if (event.request.method !== 'GET') return;

    // Skip cross-origin requests
    if (!event.request.url.startsWith(self.location.origin)) return;

    event.respondWith(
        caches.match(event.request)
            .then((cachedResponse) => {{
                if (cachedResponse) {{
                    // Return cached version
                    return cachedResponse;
                }}

                // Fetch from network
                return fetch(event.request)
                    .then((response) => {{
                        // Don't cache non-successful responses
                        if (!response || response.status !== 200) {{
                            return response;
                        }}

                        // Clone and cache
                        const responseToCache = response.clone();
                        caches.open(CACHE_NAME)
                            .then((cache) => {{
                                cache.put(event.request, responseToCache);
                            }});

                        return response;
                    }})
                    .catch(() => {{
                        // Offline fallback
                        if (event.request.mode === 'navigate') {{
                            return caches.match(OFFLINE_PAGE);
                        }}
                        return new Response('Offline', {{
                            status: 503,
                            statusText: 'Service Unavailable'
                        }});
                    }});
            }})
    );
}});
'''

    # Add background sync if enabled
    if config.background_sync:
        sw_code += '''
// Background Sync - sync pending operations when online
self.addEventListener('sync', (event) => {
    if (event.tag === 'sync-projects') {
        event.waitUntil(syncProjects());
    }
});

async function syncProjects() {
    // Get pending sync items from IndexedDB
    // and send to server
    console.log('[SW] Syncing projects...');
}
'''

    # Add push notifications if enabled
    if config.push_enabled:
        sw_code += '''
// Push Notifications
self.addEventListener('push', (event) => {
    const data = event.data ? event.data.json() : {};

    const options = {
        body: data.body || 'New update from iDAW',
        icon: '/icons/icon-192.png',
        badge: '/icons/badge-72.png',
        vibrate: [100, 50, 100],
        data: {
            url: data.url || '/'
        }
    };

    event.waitUntil(
        self.registration.showNotification(data.title || 'iDAW', options)
    );
});

self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    event.waitUntil(
        clients.openWindow(event.notification.data.url)
    );
});
'''

    return sw_code


def generate_offline_page() -> str:
    """Generate a simple offline fallback page."""
    return '''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iDAW - Offline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
        }
        .container {
            max-width: 400px;
        }
        .icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #fff;
        }
        p {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        .retry-btn {
            display: inline-block;
            padding: 12px 24px;
            background: #4a4a8a;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 500;
            transition: background 0.2s;
        }
        .retry-btn:hover {
            background: #5a5a9a;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">&#127925;</div>
        <h1>You're Offline</h1>
        <p>
            iDAW requires an internet connection for some features.
            Your work is saved locally and will sync when you're back online.
        </p>
        <a href="/" class="retry-btn">Try Again</a>
    </div>
    <script>
        // Auto-refresh when back online
        window.addEventListener('online', () => {
            window.location.reload();
        });
    </script>
</body>
</html>
'''


def create_default_config() -> PWAConfig:
    """Create default PWA configuration for iDAW."""
    icons = [
        PWAIcon(src="/icons/icon-72.png", sizes="72x72"),
        PWAIcon(src="/icons/icon-96.png", sizes="96x96"),
        PWAIcon(src="/icons/icon-128.png", sizes="128x128"),
        PWAIcon(src="/icons/icon-144.png", sizes="144x144"),
        PWAIcon(src="/icons/icon-152.png", sizes="152x152"),
        PWAIcon(src="/icons/icon-192.png", sizes="192x192"),
        PWAIcon(src="/icons/icon-384.png", sizes="384x384"),
        PWAIcon(src="/icons/icon-512.png", sizes="512x512"),
    ]

    manifest = PWAManifest(
        name="iDAW - Intelligent Digital Audio Workstation",
        short_name="iDAW",
        description="AI-powered music production and composition",
        icons=icons,
        shortcuts=[
            {
                "name": "New Project",
                "short_name": "New",
                "description": "Create a new music project",
                "url": "/new",
                "icons": [{"src": "/icons/new-96.png", "sizes": "96x96"}],
            },
            {
                "name": "Recent Projects",
                "short_name": "Recent",
                "description": "View recent projects",
                "url": "/recent",
                "icons": [{"src": "/icons/recent-96.png", "sizes": "96x96"}],
            },
        ],
    )

    static_cache = [
        "/",
        "/index.html",
        "/offline.html",
        "/css/main.css",
        "/js/app.js",
        "/icons/icon-192.png",
        "/icons/icon-512.png",
    ]

    return PWAConfig(
        manifest=manifest,
        static_cache=static_cache,
        push_enabled=False,
        background_sync=True,
    )


def write_pwa_files(output_dir: str, config: Optional[PWAConfig] = None) -> Dict[str, str]:
    """
    Write all PWA files to output directory.

    Args:
        output_dir: Output directory path
        config: PWA configuration (uses default if None)

    Returns:
        Dict mapping file paths to their content
    """
    if config is None:
        config = create_default_config()

    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    files = {
        "manifest.json": generate_manifest(config),
        "sw.js": generate_service_worker(config),
        "offline.html": generate_offline_page(),
    }

    for filename, content in files.items():
        file_path = output_path / filename
        with open(file_path, 'w') as f:
            f.write(content)

    return files
